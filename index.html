<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jacob&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jacob&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="GJH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Jacob's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jacob's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/18/%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/18/%E5%8D%8F%E7%A8%8B/" class="post-title-link" itemprop="url">协程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-18 15:46:47 / 修改时间：15:53:21" itemprop="dateCreated datePublished" datetime="2020-02-18T15:46:47+08:00">2020-02-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul>
<li>比线程更加轻量级</li>
<li>协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。<br>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</li>
<li>子程序(函数)调用顺序是明确的。而协程的调用和子程序不同。<br>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</li>
<li>协程的特点在于是一个线程执行</li>
</ul>
<h2 id="协程优势"><a href="#协程优势" class="headerlink" title="协程优势"></a>协程优势</h2><ul>
<li><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。和多线程比，线程数量越多，协程的性能优势就越明显；</p>
</li>
<li><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/18/stl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/18/stl/" class="post-title-link" itemprop="url">stl</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-18 13:33:07 / 修改时间：15:39:55" itemprop="dateCreated datePublished" datetime="2020-02-18T13:33:07+08:00">2020-02-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>底层数据结构为数组，占据一块连续的内存空间，支持快速随机访问</li>
<li>内部实现是通过管理了一个指针，只是当内存空间不够时，会重新分配一块更大的内存空间(*2)，把之前的内容挪过去</li>
<li>对尾部操作很方便，对头部或者插入都需要O(n)的时间复杂度</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>底层数据结构为双向链表，支持快速增删  </li>
<li>内存不需要连续</li>
</ul>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><ul>
<li>deque是一个双端队列(double-ended queue):  <pre><code>[堆1] --&gt; [堆2] --&gt;[堆3] --&gt; ...  </code></pre>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合 </li>
<li>deque在开始和最后添加元素都一样快(都不需要移动其他块),并提供了随机访问方法,像vector一样使用[]访问任意元素,但是随机访问速度比不上vector快,因为它要内部处理堆跳转</li>
<li>deque也有保留空间.另外,由于deque不要求连续空间,所以可以保存的元素比vector更大</li>
</ul>
<h2 id="stack-amp-amp-queue"><a href="#stack-amp-amp-queue" class="headerlink" title="stack &amp;&amp; queue"></a>stack &amp;&amp; queue</h2><ul>
<li>底层一般用list或deque实现，封闭头部即可</li>
</ul>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><ul>
<li>底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</li>
</ul>
<h2 id="set-multiset-amp-amp-map-multimap"><a href="#set-multiset-amp-amp-map-multimap" class="headerlink" title="set/multiset &amp;&amp; map/multimap"></a>set/multiset &amp;&amp; map/multimap</h2><ul>
<li>底层数据结构为红黑树</li>
<li>set &amp;&amp; map 不可重复</li>
<li>multiset &amp;&amp; multimap 可重复</li>
</ul>
<h2 id="hash-set-hash-multiset-amp-amp-hash-map-hash-multimap"><a href="#hash-set-hash-multiset-amp-amp-hash-map-hash-multimap" class="headerlink" title="hash_set/hash_multiset &amp;&amp; hash_map/hash_multimap"></a>hash_set/hash_multiset &amp;&amp; hash_map/hash_multimap</h2><ul>
<li>底层数据结构为hash表，无序</li>
<li>hash_set &amp;&amp; hash_map 不可重复 </li>
<li>hash_multiset &amp;&amp; hash_multimap 可重复</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/lsm-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/12/lsm-tree/" class="post-title-link" itemprop="url">lsm-tree</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-12 18:58:31 / 修改时间：19:27:06" itemprop="dateCreated datePublished" datetime="2020-02-12T18:58:31+08:00">2020-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>LSM 保持了日志文件写性能，以及微小的读操作性能损失。本质就是用顺序存储取代随机存储。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ol>
<li>当一些更新操作到达时，他们会被写到memtable中，memtable使用数据结构(skip list)来保持key的有序，在大部分的实现中，memtable会通过写WAL的方式备份到磁盘，用来恢复数据，防止数据丢失。当memtable数据达到一定规模时会被刷新到磁盘上的一个新文件。系统只做了顺序磁盘读写，因为没有文件被编辑，新的内容或者修改只简单的生成新的文件。  <img src="/2020/02/12/lsm-tree/tablet.png" class=""></li>
<li>所以越多的数据存储到系统中，就会有越多的不可修改的，顺序的sstable文件被创建，它们代表了小的，按时间顺序的修改。旧的文件不会被更新，重复的纪录只会通过创建新的纪录来覆盖，这也就产生了一些冗余的数据。<br>所以系统会周期的执行合并操作（compaction)。合并操作选择一些文件，并把他们合并到一起，移除重复的更新或者删除纪录，同时也会删除冗余。更重要的是，通过减少文件个数的增长，保证读操作的性能。因为sstable文件都是有序结构的，所以合并操作也是非常高效的。</li>
</ol>
<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ol>
<li>系统首先检查内存数据(memtable)，</li>
<li>如果没有找到这个key，就会逆序的一个一个检查sstable文件，直到 key 被找到。因为每个sstable都是有序的，所以查找比较高效(O(logN))，但是读操作会变的越来越慢随着sstable的个数增加，因为每一个 sstable都要被检查。（O(K log N), K为sstable个数， N 为sstable平均大小）。</li>
</ol>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>所以，读操作比其它本地更新的结构慢，幸运的是，有一些技巧可以提高性能。最基本的的方法就是页缓存（也就是leveldb的 TableCache，将sstable按照LRU缓存在内存中）在内存中，减少二分查找的消耗。</p>
<h3 id="bloom"><a href="#bloom" class="headerlink" title="bloom"></a>bloom</h3><p>通过布隆过滤器来避免大量的读文件操作，布隆过滤器是一种高效的方法来判断一个sstable中是否包含一个特定的key。（如果bloom说一个key不存在，就一定不存在，而当bloom说一个文件存在是，可能是不存在的）  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/win-Gvim%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/12/win-Gvim%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">win-Gvim配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-12 18:54:00" itemprop="dateCreated datePublished" datetime="2020-02-12T18:54:00+08:00">2020-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 07:29:14" itemprop="dateModified" datetime="2020-02-13T07:29:14+08:00">2020-02-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">&quot; Vim with all enhancements</span><br><span class="line">source $VIMRUNTIME&#x2F;vimrc_example.vim</span><br><span class="line"></span><br><span class="line">&quot; Use the internal diff if available.</span><br><span class="line">&quot; Otherwise use the special &#39;diffexpr&#39; for Windows.</span><br><span class="line">if &amp;diffopt !~# &#39;internal&#39;</span><br><span class="line">		set diffexpr&#x3D;MyDiff()</span><br><span class="line">endif</span><br><span class="line">function MyDiff()</span><br><span class="line">		let opt &#x3D; &#39;-a --binary &#39;</span><br><span class="line">		if &amp;diffopt &#x3D;~ &#39;icase&#39; | let opt &#x3D; opt . &#39;-i &#39; | endif</span><br><span class="line">		if &amp;diffopt &#x3D;~ &#39;iwhite&#39; | let opt &#x3D; opt . &#39;-b &#39; | endif</span><br><span class="line">		let arg1 &#x3D; v:fname_in</span><br><span class="line">		if arg1 &#x3D;~ &#39; &#39; | let arg1 &#x3D; &#39;&quot;&#39; . arg1 . &#39;&quot;&#39; | endif</span><br><span class="line">		let arg1 &#x3D; substitute(arg1, &#39;!&#39;, &#39;\!&#39;, &#39;g&#39;)</span><br><span class="line">		let arg2 &#x3D; v:fname_new</span><br><span class="line">		if arg2 &#x3D;~ &#39; &#39; | let arg2 &#x3D; &#39;&quot;&#39; . arg2 . &#39;&quot;&#39; | endif</span><br><span class="line">		let arg2 &#x3D; substitute(arg2, &#39;!&#39;, &#39;\!&#39;, &#39;g&#39;)</span><br><span class="line">		let arg3 &#x3D; v:fname_out</span><br><span class="line">		if arg3 &#x3D;~ &#39; &#39; | let arg3 &#x3D; &#39;&quot;&#39; . arg3 . &#39;&quot;&#39; | endif</span><br><span class="line">		let arg3 &#x3D; substitute(arg3, &#39;!&#39;, &#39;\!&#39;, &#39;g&#39;)</span><br><span class="line">		if $VIMRUNTIME &#x3D;~ &#39; &#39;</span><br><span class="line">				if &amp;sh &#x3D;~ &#39;\&lt;cmd&#39;</span><br><span class="line">						if empty(&amp;shellxquote)</span><br><span class="line">								let l:shxq_sav &#x3D; &#39;&#39;</span><br><span class="line">								set shellxquote&amp;</span><br><span class="line">						endif</span><br><span class="line">						let cmd &#x3D; &#39;&quot;&#39; . $VIMRUNTIME . &#39;\diff&quot;&#39;</span><br><span class="line">				else</span><br><span class="line">						let cmd &#x3D; substitute($VIMRUNTIME, &#39; &#39;, &#39;&quot; &#39;, &#39;&#39;) . &#39;\diff&quot;&#39;</span><br><span class="line">				endif</span><br><span class="line">		else</span><br><span class="line">				let cmd &#x3D; $VIMRUNTIME . &#39;\diff&#39;</span><br><span class="line">		endif</span><br><span class="line">		let cmd &#x3D; substitute(cmd, &#39;!&#39;, &#39;\!&#39;, &#39;g&#39;)</span><br><span class="line">		silent execute &#39;!&#39; . cmd . &#39; &#39; . opt . arg1 . &#39; &#39; . arg2 . &#39; &gt; &#39; . arg3</span><br><span class="line">		if exists(&#39;l:shxq_sav&#39;)</span><br><span class="line">				let &amp;shellxquote&#x3D;l:shxq_sav</span><br><span class="line">		endif</span><br><span class="line">endfunction</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">filetype off  </span><br><span class="line">&quot; 此处规定Vundle的路径  </span><br><span class="line">set rtp+&#x3D;$VIM&#x2F;vimfiles&#x2F;bundle&#x2F;vundle&#x2F;  </span><br><span class="line">call vundle#rc(&#39;$VIM&#x2F;vimfiles&#x2F;bundle&#x2F;&#39;)  </span><br><span class="line">Bundle &#39;gmarik&#x2F;vundle&#39;  </span><br><span class="line">filetype plugin indent on  </span><br><span class="line"></span><br><span class="line">&quot; original repos on github&lt;br&gt;Bundle &#39;mattn&#x2F;zencoding-vim&#39;  </span><br><span class="line">Bundle &#39;drmingdrmer&#x2F;xptemplate&#39;  </span><br><span class="line"></span><br><span class="line">&quot; vim-scripts repos  </span><br><span class="line">Bundle &#39;The-NERD-tree&#39;  </span><br><span class="line">map &lt;F2&gt; :NERDTreeMirror&lt;CR&gt;</span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">Bundle &#39;fatih&#x2F;vim-go&#39;   </span><br><span class="line">filetype plugin indent on     &quot; required!</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;markdown&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">Bundle &#39;iamcco&#x2F;mathjax-support-for-mkdp&#39;</span><br><span class="line">Bundle &#39;iamcco&#x2F;markdown-preview.vim&#39;</span><br><span class="line">nmap &lt;silent&gt; &lt;F3&gt; &lt;Plug&gt;MarkdownPreview        &quot; for normal mode</span><br><span class="line">imap &lt;silent&gt; &lt;F3&gt; &lt;Plug&gt;MarkdownPreview        &quot; for insert mode</span><br><span class="line">nmap &lt;silent&gt; &lt;F4&gt; &lt;Plug&gt;StopMarkdownPreview    &quot; for normal mode</span><br><span class="line">imap &lt;silent&gt; &lt;F4&gt; &lt;Plug&gt;StopMarkdownPreview    &quot; for insert mode</span><br><span class="line">&quot;Bundle &#39;godlygeek&#x2F;tabular&#39;</span><br><span class="line">&quot;Bundle &#39;plasticboy&#x2F;vim-markdown&#39;</span><br><span class="line">&quot;Bundle &#39;suan&#x2F;vim-instant-markdown&#39;</span><br><span class="line">&quot;Bundle &#39;iamcco&#x2F;markdown-preview.nvim&#39;</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">set shortmess&#x3D;atI   &quot; 启动的时候不显示那个援助乌干达儿童的提示  </span><br><span class="line">&quot;winpos 5 5          &quot; 设定窗口位置  </span><br><span class="line">&quot;set lines&#x3D;40 columns&#x3D;155    &quot; 设定窗口大小  </span><br><span class="line">set nu              &quot; 显示行号  </span><br><span class="line">&quot;set go&#x3D;             &quot; 不要图形按钮  </span><br><span class="line">color desert     &quot; 设置背景主题  </span><br><span class="line">set guifont&#x3D;Consolas:h13:cANSI   &quot; 设置字体  </span><br><span class="line">syntax on           &quot; 语法高亮  </span><br><span class="line">autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行  </span><br><span class="line">autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行  </span><br><span class="line">&quot;set ruler           &quot; 显示标尺  </span><br><span class="line">set showcmd         &quot; 输入的命令显示出来，看的清楚些  </span><br><span class="line">&quot;set cmdheight&#x3D;1     &quot; 命令行（在状态行下）的高度，设置为1  </span><br><span class="line">&quot;set whichwrap+&#x3D;&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)  </span><br><span class="line">&quot;set scrolloff&#x3D;3     &quot; 光标移动到buffer的顶部和底部时保持3行距离  </span><br><span class="line">set novisualbell    &quot; 不要闪烁(不明白)  </span><br><span class="line">set statusline&#x3D;%F%m%r%h%w\ [FORMAT&#x3D;%&#123;&amp;ff&#125;]\ [TYPE&#x3D;%Y]\ [POS&#x3D;%l,%v][%p%%]\ %&#123;strftime(\&quot;%d&#x2F;%m&#x2F;%y\ -\ %H:%M\&quot;)&#125;   &quot;状态行显示的内容  </span><br><span class="line">set laststatus&#x3D;1    &quot; 启动显示状态行(1),总是显示状态行(2)  </span><br><span class="line">set foldenable      &quot; 允许折叠  </span><br><span class="line">set foldmethod&#x3D;manual   &quot; 手动折叠  </span><br><span class="line">set guioptions-&#x3D;T           &quot; 隐藏工具栏</span><br><span class="line">&quot;set guioptions-&#x3D;m           &quot; 隐藏菜单栏</span><br><span class="line">set tabstop&#x3D;4 &quot; Tab键的宽度</span><br><span class="line">set nobackup &quot;从不备份 </span><br><span class="line">set noundofile</span><br><span class="line">set noswapfile</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;utf-8&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">set encoding&#x3D;utf-8  </span><br><span class="line">set termencoding&#x3D;utf-8  </span><br><span class="line">set fileencoding&#x3D;chinese </span><br><span class="line">set fileencodings&#x3D;ucs-bom,utf-8,chinese   </span><br><span class="line"></span><br><span class="line">set langmenu&#x3D;zh_CN.utf-8  </span><br><span class="line">source $VIMRUNTIME&#x2F;delmenu.vim  </span><br><span class="line">source $VIMRUNTIME&#x2F;menu.vim  </span><br><span class="line">language messages zh_cn.utf-8   </span><br><span class="line"></span><br><span class="line">language messages zh_cn.utf-8</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/bigtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/12/bigtable/" class="post-title-link" itemprop="url">bigtable</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-12 04:45:58 / 修改时间：05:09:46" itemprop="dateCreated datePublished" datetime="2020-02-12T04:45:58+08:00">2020-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据模型："><a href="#数据模型：" class="headerlink" title="数据模型："></a>数据模型：</h2><p>Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序 Map。Map 的索引是行关键字、列关键字以及时间戳；Map 中的每个 value 都是一个未经解析的 byte 数组。 </p>
<img src="/2020/02/12/bigtable/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" class="">

<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>表中的行关键字可以是任意的字符串（目前支持最大 64KB 的字符串）。对同一个行关键字的读或者写操作都是原子的（不管读或者写这一行里多少个不同列）。<br>Bigtable通过行关键字的字典顺序来组织数据。表中的每一个行都可以动态分区。每个分区叫做一个Tablet，Tablet是数据分布和负载均衡调整的最小单位。</p>
<h3 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h3><p>列关键字组成的集合叫做“列族”，列族是访问控制的基本单位。列族在使用之前必须先创建，然后才能在列族中任何的列关键字下存放数据；列族创建后，其中任何一个列关键字下都可以存放数据。一张表中的列族不能太多（最多几百个），且列族在运行期间很少改变。相反，一张表可以有无限多个列。<br>列族的名字必须是可打印的字符串。访问控制，磁盘和内存的使用统计都是在列族层面进行的。</p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p> 在Bigtable中，表的每一个数据项都可以包含同一份数据的不同版本；不同版本的数据通过时间戳来索引。Bigtable时间戳的类型是64位整型。数据项中，不同版本的数据按照时间戳倒序排序，即最新的数据排序在最前面。<br>为了减轻多个版本数据的管理负担，我们对每一个列族配有两个设置参数，Bigtable 通过这两个参数可以对废弃版本的数据自动进行垃圾收集。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Bigtable提供了建立和删除表以及列族的API函数。Bigtable还提供了修改集群，表和列族的元数据的API，比如修改访问权限。<br>客户程序可以对Bigtable进行如下的操作：写入和删除Bigtable中的值，从每个行中查找值，或者遍历表中的一个数据子集。<br>Bigtable还可以和Mapreduce程序一起使用，可以作为MapReduce框架的输入和输出。</p>
<h2 id="BigTable构件"><a href="#BigTable构件" class="headerlink" title="BigTable构件"></a>BigTable构件</h2><p>Bigtable构件是建立在其他几个Google基础构件上的。Bigtable使用Google的分布式文件系统GFS存储日志文件和数据文件。Bigtable集群通常运行在一个共享的机器池中，池中的机器还会运行其他的各种各样的分布式应用程序。<br>Bigtable内部存储数据的文件是Google SSTable格式的。SSTable是一个持久化的，排序的，不可更改的Map结构，而Map是一个key-value映射的数据结构，key和value都是任意的Byte串。<br>Bigtable还依赖一个高可用的，序列化的分布式锁服务器组件，叫做Chubby。Bigtable使用Chubby完成以下几个任务：</p>
<ol>
<li>确保在任何给定的时间内最多只有一个活动的Master副本；</li>
<li>存储Bigtable数据的自引导指令的位置；</li>
<li>查找Tablet服务器，以及在Tablet服务器失效时进行善后；</li>
<li>存储Bigtable的模式信息（每张表的列族信息）；</li>
<li>以及存储访问控制列表。</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Bigtable包括了三个主要的组件：链接到客户程序中的库，一个Master服务器和多个Tablet服务器。针对系统工作负载的变化情况，Bigtable可以动态的向集群中添加（或者删除）Tablet服务器。  </p>
<ul>
<li>Master服务器：为Tablet服务器分配Tablets、检测新加入的或者过期失效的Table服务器、对Tablet服务器进行负载均衡、以及对保存在GFS上的文件进行垃圾收集。  </li>
<li>Tablet服务器:管理一个 Tablet 的集合。每个Tablet服务器负责处理它所加载的 Tablet 的读写操作，以及在 Tablets 过大时，对其进行分割。</li>
<li>客户端:读取的数据都不经过Master服务器，客户程序直接和Tablet服务器通信进行读写操作。</li>
</ul>
<p>一个BigTable集群存储了很多表，每个表包含了一个Tablet的集合，而每个Tablet包含了某个范围内的行的所有相关数据。初始状态下，一个表只有一个Tablet。随着表中数据的增长，它被自动分割成多个Tablet，缺省情况下，每个Tablet的尺寸大约是100MB到200MB。</p>
<h3 id="Tablet的位置"><a href="#Tablet的位置" class="headerlink" title="Tablet的位置"></a>Tablet的位置</h3><p>用一个三层的、类似Ｂ+树的结构存储Tablet的位置信息：</p>
<img src="/2020/02/12/bigtable/tablet%E4%BD%8D%E7%BD%AE.png" class="">

<p>第一层是一个存储在 Chubby 中的文件，它包含了 Root Tablet 的位置信息。Root Tablet 包含了一个特殊的 METADATA 表里所有的 Tablet 的位置信息。METADATA 表的每个 Tablet 包含了一个用户 Tablet 的集合。Root Tablet 实际上是 METADATA 表的第一个 Tablet，只不过对它的处理比较特殊 — Root Tablet 永远不会被分割 — 这就保证了 Tablet 的位置信息存储结构不会超过三层。</p>
<h3 id="Tablet的分配"><a href="#Tablet的分配" class="headerlink" title="Tablet的分配"></a>Tablet的分配</h3><p>在任何一个时刻，一个Tablet只能分配给一个Tablet服务器，由master控制。<br>BigTable使用Chubby跟踪记录Tablet服务器的状态。当一个 Tablet 服务器启动时，它在 Chubby 的一个指定目录下建立一个有唯一性名字的文件，并且获取该文件的独占锁。Master 服务器实时监控着这个目录（服务器目录）<br>Master 服务器负责检查一个 Tablet 服务器是否已经不再为它的 Tablet 提供服务了，并且要尽快重新分配它加载的 Tablet。<br>当集群管理系统启动了一个Master服务器之后，Master服务器首先要了解当前Tablet的分配状态，之后才能够修改分配状态。Master服务器在启动的时候执行以下步骤：</p>
<ol>
<li>Master服务器从Chubby获取一个唯一的Master锁，用来阻止创建其它的Master服务器实例；</li>
<li>Master服务器扫描Chubby的服务器文件锁存储目录，获取当前正在运行的服务器列表；</li>
<li>Master服务器和所有的正在运行的Tablet表服务器通信，获取每个Tablet服务器上Tablet的分配信息；</li>
<li>Master服务器扫描METADATA表获取所有的Tablet的集合。<br>在扫描的过程中，当Master服务器发现了一个还没有分配的Tablet，Master服务器就将这个Tablet加入未分配的Tablet集合等待合适的时机分配。</li>
</ol>
<h3 id="Tablet服务"><a href="#Tablet服务" class="headerlink" title="Tablet服务"></a>Tablet服务</h3><img src="/2020/02/12/bigtable/tablet%E6%9C%8D%E5%8A%A1.png" class="">

<h3 id="空间收缩"><a href="#空间收缩" class="headerlink" title="空间收缩"></a>空间收缩</h3><p>随着写操作的执行，memtable的大小不断增加。当memtable的尺寸到达一个门限值的时候，这个memtable就会被冻结，然后创建一个新的memtable；被冻结住memtable按照SSTable格式写入GFS。  </p>
<p>MinorCompaction过程有两个目的：</p>
<ol>
<li>shrink Tablet服务器使用的内存，以及在服务器灾难恢复过程中，减少必须从提交日志里读取的数据量。</li>
<li>在Compaction过程中，正在进行的读写操作仍能继续。<br>MajorCompaction机制允许Bigtable回收已经删除的数据占有的资源，并且确保BigTable能及时清除已经删除的数据，这对存放敏感数据的服务是非常重要。</li>
</ol>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="局部性群组"><a href="#局部性群组" class="headerlink" title="局部性群组"></a>局部性群组</h3><p>客户程序可以将多个列族组合成一个局部性群族。对 Tablet 中的每个局部性群组都会生成一个单独的SSTable。将通常不会一起访问的列族分割成不同的局部性群组可以提高读取操作的效率。<br>可以把一个局部性群组设定为全部存储在内存中。Tablet服务器依照惰性加载的策略将设定为放入内存的局部性群组的SSTable装载进内存。加载完成之后，访问属于该局部性群组的列族的时候就不必读取硬盘了。这个特性对于需要频繁访问的小块数据特别有用：在Bigtable内部，我们利用这个特性提高METADATA表中具有位置相关性的列族的访问速度。</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>很多客户程序使用了“两遍”的、可定制的压缩方式。第一遍采用Bentley and McIlroy’s方式，这种方式在一个很大的扫描窗口里对常见的长字符串进行压缩；第二遍是采用快速压缩算法，即在一个16KB的小扫描窗口中寻找重复数据。</p>
<h3 id="通过缓存提高读操作的性能"><a href="#通过缓存提高读操作的性能" class="headerlink" title="通过缓存提高读操作的性能"></a>通过缓存提高读操作的性能</h3><p>为了提高读操作的性能，Tablet服务器使用二级缓存的策略。</p>
<ul>
<li>扫描缓存是第一级缓存，主要缓存Tablet服务器通过SSTable接口获取的Key-Value对；对于经常要重复读取相同数据的应用程序来说，扫描缓存非常有效</li>
<li>Block缓存是二级缓存，缓存的是从GFS读取的SSTable的Block。对于经常要读取刚刚读过的数据附近的数据的应用程序来说，Block缓存更有用（例如，顺序读，或者在一个热点的行的局部性群组中随机读取不同的列)。</li>
</ul>
<h4 id="Bloom-过滤器"><a href="#Bloom-过滤器" class="headerlink" title="Bloom 过滤器"></a>Bloom 过滤器</h4><p>一个读操作必须读取构成 Tablet 状态的所有 SSTable 的数据。如果这些 SSTable 不在内存中，那么就需要多次访问硬盘。我们通过允许客户程序对特定局部性群组的 SSTable 指定 Bloom 过滤器，来减少硬盘访问的次数。我们可以使用 Bloom 过滤器查询一个 SSTable 是否包含了特定行和列的数据。对于某些特定应用程序，我们只付出了少量的、用于存储 Bloom 过滤器的内存的代价，就换来了读操作显著减少的磁盘访问的次数。使用 Bloom 过滤器也隐式的达到了当应用程序访问不存在的行或列时，大多数时候我们都不需要访问硬盘的目的。 </p>
<h4 id="Commit-日志的实现"><a href="#Commit-日志的实现" class="headerlink" title="Commit 日志的实现"></a>Commit 日志的实现</h4><p>如果我们把对每个 Tablet 的操作的 Commit 日志都存在一个单独的文件的话，那么就会产生大量的文件，并且这些文件会并行的写入 GFS。<br>设置每个 Tablet 服务器一个 Commit 日志文件，把修改操作的日志以追加方式写入同一个日志文件，因此一个实际的日志文件中混合了对多个 Tablet 修改的日志记录。</p>
<h4 id="Tablet-恢复提速"><a href="#Tablet-恢复提速" class="headerlink" title="Tablet 恢复提速"></a>Tablet 恢复提速</h4><p>当 Master 服务器将一个 Tablet 从一个 Tablet 服务器移到另外一个 Tablet 服务器时，源 Tablet 服务器会对这个 Tablet 做一次 Minor Compaction。这个 Compaction 操作减少了 Tablet 服务器的日志文件中没有归并的记录，从而减少了恢复的时间。Compaction 完成之后，该服务器就停止为该 Tablet 提供服务。在卸载 Tablet 之前，源 Tablet 服务器还会再做一次（通常会很快）Minor Compaction，以消除前面在一次压缩过程中又产生的未归并的记录。第二次 Minor Compaction 完成以后，Tablet 就可以被装载到新的 Tablet 服务器上了，并且不需要从日志中进行恢复。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/gfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/gfs/" class="post-title-link" itemprop="url">gfs</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-11 08:49:06 / 修改时间：21:55:53" itemprop="dateCreated datePublished" datetime="2020-02-11T08:49:06+08:00">2020-02-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>GFS 是一个大型的分布式文件系统，为 Google 大数据处理系统提供海量存储，并且与 MapReduce 和 BigTable 等技术结合得十分紧密，处于系统的底层。</p>
<ol>
<li>普通商用的机器硬件发生故障是常态</li>
<li>存储的问题普遍比较大，几个G的文件很常见</li>
<li>大部分的文件操作都是在追加数据，覆盖原来写入的数据的情况比较少见，随机写几乎不存在</li>
<li>读操作主要包括两种，large streaming read和small random read</li>
<li>为了应用使用方便，多客户端并行地追加同一个文件需要非常高效</li>
<li>带宽的重要性大于时延，目标应用是高速读大块数据的应用，对响应时间没有过多的需求</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>文件以分层目录的形式组织，用路径名来标识。我们支持常用的操作，如创建新文件、删除文件、打开文件、关闭文件、读和写文件<br>另外，GFS 提供了快照和记录追加操作。快照以很低的成本创建一个文件或者目录树的拷贝。记录追加操作允许多个客户端同时对一个文件进行数据追加操作，同时保证每个客户端的追加操作都是原子性的。这对于实现多路结果合并，以及“生产者-消费者”队列非常有用，多个客户端可以在不需要额外的同步锁定的情况下，同时对一个文件追加数据。我们发现这些类型的文件对于构建大型分布应用是非常重要的</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><img src="/2020/02/11/gfs/%E6%9E%B6%E6%9E%84.png" class="">

<p>一个 GFS 集群包含一个单独的 Master 节点3、多台 Chunk 服务器，并且同时被多个客户端访问<br>GFS 存储的文件都被分割成固定大小的 Chunk(64MB)。在 Chunk 创建的时候，Master 服务器会给每个 Chunk 分配一个不变的、全球唯一的 64 位的 Chunk 标识。Chunk 服务器把 Chunk 以 Linux 文件的形式保存在本地硬盘上，并且根据指定的 Chunk 标识和字节范围来读写块数据。出于可靠性的考虑，每个块都会复制到多个块服务器上(一般三个，可设置)。</p>
<h3 id="元数据节点"><a href="#元数据节点" class="headerlink" title="元数据节点"></a>元数据节点</h3><p>也称为Master。主要负责维护文件和 Chunk 的命名空间、文件和 Chunk 的对应关系、每个 Chunk 副本的存放地点等元数据，并与 Chunk Server 通信。<br>Master Server 的所有信息都存储在内存里，启动时信息从 Chunk Server 中获取。这样不但提高了 Master Server 的性能和吞吐量，也有利于 Master Server 宕机后把后备服务器切换成 Master Server。</p>
<h3 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h3><p>是文件chunk的存储位置。每个数据节点挂载多个磁盘设备并将其格式化为本地文件系统（如XFS）。将客户端写入数据以Chunk为单位存储，存储形式为本地文件。<br>Chunk Server 在硬盘上存储实际数据。Google 把每个 chunk 数据块的大小设计成 64MB，每个 chunk 被复制成 3 个副本放到不同的 Chunk Server 中，以创建冗余来避免服务器崩溃。如果某个 Chunk Server 发生故障，Master Server 便把数据备份到一个新的地方。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Client 是应用程序访问 GFS 的接口。</p>
<h2 id="GFS-的系统架构设计的优势"><a href="#GFS-的系统架构设计的优势" class="headerlink" title="GFS 的系统架构设计的优势"></a>GFS 的系统架构设计的优势</h2><ol>
<li>Client 和 Master Server 之间只有控制流，没有数据流，因此降低了 Master Server 的负载。</li>
<li>由于 Client 与 Chunk Server 之间直接传输数据流，并且文件被分成多个 Chunk 进行分布式存储，因此 Client 可以同时并行访问多个 Chunk Server，从而让系统的 I/O 并行度提高。</li>
<li>Google 通过减少 Client 与 Master Server 的交互来解决 Master Server 的性能瓶颈冋题。Client 直接与 Chunk Server 进行通信，Master Server 仅提供查询数据块所在的 Chunk Server 的详细位置的功能。</li>
<li>数据块设计成 64MB，也是为了让客户端和 Master Server 的交互减少，让主要数据流量在客户端程序和 Chunk Server 之间直接交互。</li>
</ol>
<h2 id="GFS特点"><a href="#GFS特点" class="headerlink" title="GFS特点"></a>GFS特点</h2><ol>
<li>采用中心服务器模式，带来以下优势。<ul>
<li>可以方便地增加 Chunk Server。</li>
<li>Master Server可以掌握系统内所有 Chunk Server 的情况，方便进行负载均衡。</li>
<li>不存在元数据的一致性问题。</li>
</ul>
</li>
<li>不缓存数据，具有以下优势。<ul>
<li>文件操作大部分是流式读/写，不存在大量重复的读/写，因此即使使用缓存对系统性能的提高也不大。</li>
<li>Chunk Server 上的数据存储在本地文件系统上，即使真的出现频繁存取的情况，本地文件系统的缓存也可以支持。</li>
<li>若建立系统缓存，那么缓存中的数据与 Chunk Server 中的数据的一致性很难保证</li>
</ul>
</li>
</ol>
<h2 id="GFS-一致性模型"><a href="#GFS-一致性模型" class="headerlink" title="GFS 一致性模型"></a>GFS 一致性模型</h2><img src="/2020/02/11/gfs/%E4%B8%80%E8%87%B4%E6%80%A7.png" class="">

<h2 id="租约和变更顺序"><a href="#租约和变更顺序" class="headerlink" title="租约和变更顺序"></a>租约和变更顺序</h2><p>变更是一个会改变 Chunk 内容或者元数据的操作，比如写入操作或者记录追加操作。变更操作会在 Chunk的所有副本上执行。租约（lease）机制用于保持多个副本间变更顺序的一致性。<br>GFS在chunk多副本之间选择出一个主副本，由主副本来协调客户端的写入，保证多副本之间维持一个全局统一的更新顺序。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序首先由 Master节点选择的租约的顺序决定，然后由租约中主 Chunk 分配的序列号决定。<br>租约（Lease）是由GFS中心节点Master分配给chunk的某个副本的锁。持有租约的副本方可处理客户端的更新请求，客户端更新数据前会从Master获取该chunk持有租约的副本并向该副本发送更新请求。 租约有时间限制(60s),主chunk可以续约</p>
<h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><img src="/2020/02/11/gfs/%E5%86%99%E5%85%A5%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B.png" class="">
<ol>
<li>客户机向 Master 节点询问哪一个 Chunk 服务器持有当前的租约，以及其它副本的位置。如果没有一个Chunk 持有租约，Master 节点就选择其中一个副本建立一个租约</li>
<li>Master 节点将主 Chunk 的标识符以及其它副本的位置返回给客户机。客户机缓存这些数据以便后续的操作。只有在主 Chunk 不可用，或者主 Chunk 回复信息表明它已不再持有租约的时候，客户机才需要重新跟 Master 节点联系 </li>
<li>客户机把数据推送到所有的副本上。chunkserver会缓存这些数据，此时数据存在内部 LRU 缓冲中，并不落盘</li>
<li>当所有的副本都确认接收到了数据，客户机发送写请求到主 Chunk 服务器。这个请求标识了早前推送到所有副本的数据。</li>
<li>主 Chunk 把写请求传递到所有的二级副本。每个二级副本依照主 Chunk 分配的序列号以相同的顺序执行这些操作。此时数据方才落盘</li>
<li>所有的二级副本回复主 Chunk，它们已经完成了操作。 </li>
<li>主 Chunk 服务器回复客户机。</li>
</ol>
<h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>快照操作几乎可以瞬间完成对一个文件或者目录树（“源”）做一个拷贝，并且几乎不会对正在进行的其它操作造成任何干扰。我们的用户可以使用快照迅速的创建一个巨大的数据集的分支拷贝（而且经常是递归的拷贝拷贝），或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的提交或者回滚到备份时的状态。</p>
<h2 id="chunk副本位置"><a href="#chunk副本位置" class="headerlink" title="chunk副本位置"></a>chunk副本位置</h2><p>Chunk 副本位置选择的策略服务两大目标：最大化数据可靠性和可用性，最大化网络带宽利用率。<br>创建chunk时副本位置的选择算法：</p>
<ol>
<li>选择存储空间利用率最低的节点和磁盘；</li>
<li>选择最近一段时间内新建chunk数量较少的节点和磁盘；</li>
<li>将多个副本分散在不同的rack上。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/mapreduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/mapreduce/" class="post-title-link" itemprop="url">mapreduce</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-11 08:06:45 / 修改时间：08:46:22" itemprop="dateCreated datePublished" datetime="2020-02-11T08:06:45+08:00">2020-02-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><img src="/2020/02/11/mapreduce/mapreduce.png" class="">

<p>首先，用户通过 MapReduce 客户端指定 Map 函数和 Reduce 函数，以及此次 MapReduce 计算的配置，包括中间结果键值对的 Partition 数量 R 以及用于切分中间结果的哈希函数 hash。 用户开始 MapReduce 计算后，整个 MapReduce 计算的流程可总结如下：</p>
<ol>
<li>作为输入的文件会被分为 M个 Split，每个 Split 的大小通常在 16~64 MB 之间</li>
<li>如此，整个 MapReduce 计算包含 M 个Map 任务和 R 个 Reduce 任务。Master 结点会从空闲的 Worker 结点中进行选取并为其分配 Map 任务和 Reduce 任务</li>
<li>Mapper们开始读入自己对应的 Split，将读入的内容解析为输入键值对并调用由用户定义的 Map 函数。由 Map 函数产生的中间结果键值对会被暂时存放在缓冲内存区中</li>
<li>在 Map 阶段进行的同时，Mapper们周期性地将放置在缓冲区中的中间结果存入到自己的本地磁盘中，同时根据用户指定的 Partition 函数（默认为 hash(key) mod R）将产生的中间结果分为 R 个部分。任务完成时，Mapper 便会将中间结果在其本地磁盘上的存放位置报告给 Master</li>
<li>Mapper 上报的中间结果存放位置会被 Master 转发给 Reducer。当 Reducer 接收到这些信息后便会读取存储在 Mapper 本地磁盘上属于对应 Partition 的中间结果。在读取完毕后，Reducer 会对读取到的数据进行排序，以令拥有相同键的键值对能够连续分布</li>
<li>之后，Reducer 会为每个键收集与其关联的值的集合，并以之调用用户定义的 Reduce 函数。Reduce 函数的结果会被放入到对应的 Reduce Partition 结果文件</li>
</ol>
<p>实际上，在一个 MapReduce 集群中，Master 会记录每一个 Map 和 Reduce 任务的当前完成状态，以及所分配的 Worker。除此之外，Master 还负责将 Mapper 产生的中间结果文件的位置和大小转发给 Reducer。</p>
<p>值得注意的是，每次 MapReduce 任务执行时，M 和 R 的值都应比集群中的 Worker 数量要高得多，以达成集群内负载均衡的效果。</p>
<h2 id="Master-数据结构"><a href="#Master-数据结构" class="headerlink" title="Master 数据结构"></a>Master 数据结构</h2><p>Master 持有一些数据结构，它存储每一个 Map 和 Reduce 任务的状态（空闲、工作中或完成)，以及 Worker机器(非空闲任务的机器)的标识。<br>当 Map任务完成时，Master 接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的 Reduce 任务</p>
<h2 id="MapReduce-容错机制"><a href="#MapReduce-容错机制" class="headerlink" title="MapReduce 容错机制"></a>MapReduce 容错机制</h2><h3 id="Worker-失效"><a href="#Worker-失效" class="headerlink" title="Worker 失效"></a>Worker 失效</h3><p>在 MapReduce 集群中，Master 会周期地向每一个 Worker 发送 Ping 信号。如果某个 Worker 在一段时间内没有响应，Master 就会认为这个 Worker 已经不可用。</p>
<ul>
<li><p>mapper失效<br>任何分配给该 Worker 的 Map 任务，无论是正在运行还是已经完成，都需要由 Master 重新分配给其他 Worker，因为存储在该 Worker 本地磁盘上的中间结果也不可用了。Master 也会将这次重试通知给所有 Reducer</p>
</li>
<li><p>reducer失效<br>如果有 Reduce 任务分配给失效 Worker，Master 则会选取其中尚未完成的 Reduce 任务分配给其他 Worker。已完成的 Reduce 任务的结果有GFS提供备份，因此 MapReduce Master 只需要处理未完成的 Reduce 任务即可</p>
</li>
</ul>
<h3 id="Master-失效"><a href="#Master-失效" class="headerlink" title="Master 失效"></a>Master 失效</h3><p>整个 MapReduce 集群中只会有一个 Master 结点，因此 Master 失效的情况并不多见。<br>Master 结点在运行时会周期性地将集群的当前状态作为保存点（Checkpoint）写入到磁盘中。Master 进程终止后，重新启动的 Master 进程即可利用存储在磁盘中的数据恢复到上一次保存点的状态。</p>
<h2 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h2><p>通过尽量把输入数据(由 GFS 管理)存储在集群中机器的本地磁盘上来节省网络带宽。<br>GFS 把每个文件按 64MB 一个 Block 分隔，每个 Block 保存在多台机器上，环境中就存放了多份拷贝(一般是 3 个拷贝)</p>
<ul>
<li>MapReduce 的 master 在调度 Map 任务时会考虑输入文件的位置信息，尽量将一个 Map 任务调度在包含相关输入数据拷贝的机器上执行；</li>
<li>如果上述努力失败了，master 将尝试在保存有输入数据拷贝的机器附近的机器上执行 Map 任务</li>
</ul>
<h2 id="任务粒度"><a href="#任务粒度" class="headerlink" title="任务粒度"></a>任务粒度</h2><p>Map被拆分成了 M 个片段、 Reduce被 拆分成 R 个片段执行。理想情况下，M 和 R 应当比集群中 worker 的机器数量要多得多。在每台 worker 机器都执行大量的不同任务能够提高集群的动态的负载均衡能力，并且能够加快故障恢复的速度：失效机器上执行的大量 Map 任务都可以分布到所有其他的 worker 机器上去执行。</p>
<p>但是实际上， 在具体实现中对 M 和 R 的取值都有一定的客观限制， 因为 master 必须执行 O(M+R) 次调度，并且在内存中保存 O(M*R)个状态（对影响内存使用的因素还是比较小的：O(M*R)块状态，大概每对 Map 任务/Reduce 任务 1 个字节就可以了） 。</p>
<p>更进一步，R 值通常是由用户指定的，因为每个 Reduce 任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的 M 值，以使得每一个独立任务都是处理大约 16M 到 64M 的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把 R 值设置为我们想使用的 worker 机器数量的小的倍数。</p>
<h2 id="备用任务"><a href="#备用任务" class="headerlink" title="备用任务"></a>备用任务</h2><p>如果集群中有某个 Worker 花了特别长的时间来完成最后的几个 Map 或 Reduce 任务，整个 MapReduce 计算任务的耗时就会因此被拖长，这样的 Worker 也就成了落后者（Straggler）。</p>
<p>MapReduce 在整个计算完成到一定程度时就会将剩余的任务进行备份，即同时将其分配给其他空闲 Worker 来执行，并在其中一个 Worker 完成后将该任务视作已完成。</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="分区函数"><a href="#分区函数" class="headerlink" title="分区函数"></a>分区函数</h3><p>一个缺省的分区函数是使用 hash 方法(比如，hash(key) mod R)进行分区。hash 方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对 key 值进行的分区将非常有用。比如，输出的 key 值是 URLs，希望每个主机的所有条目保持在同一个输出文件中。 为了支持类似的情况，MapReduce库的用户需要提供专门的分区函数。例如，使用 “hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的 URLs 保存在同一个输出文件中。</p>
<h3 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h3><p>MapReduce确保在给定的分区中，中间 key/value pair 数据的处理顺序是按照 key 值增量顺序处理的。这样的顺序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按 key 值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</p>
<h3 id="Combiner"><a href="#Combiner" class="headerlink" title="Combiner"></a>Combiner</h3><p>在某些情形下，用户所定义的 Map 任务可能会产生大量重复的中间结果键，同时用户所定义的 Reduce 函数本身也是满足交换律和结合律的。</p>
<p>在这种情况下，Google MapReduce 系统允许用户声明在 Mapper 上执行的 Combiner 函数,减少 Mapper 和 Reducer 间需要传输的数据量<br>combiner 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去<br>Combiner 函数在每台执行 Map 任务的机器上都会被执行一次</p>
<h3 id="输入和输出的类型"><a href="#输入和输出的类型" class="headerlink" title="输入和输出的类型"></a>输入和输出的类型</h3><p>MapReduce库支持几种不同的格式的输入数据。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的 Map 任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。  </p>
<p>例子：</p>
<ul>
<li>文本模式的输入数据的每一行被视为是一个key/value pair。key 是文件的偏移量，value 是那一行的内容。</li>
<li>以 key 进行排序来存储的 key/value pair 的序列。</li>
<li>Reader 并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的 Reader，或者从内存中的数据结构读取数据的 Reader。</li>
</ul>
<p>类似的，MapReduce提供了一些预定义的输出数据的类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。</p>
<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>在某些情况下，MapReduce 的使用者发现，如果在 Map 和/或 Reduce 操作过程中增加辅助的输出文件会比较省事。我们依靠程序 writer 把这种“副作用”变成原子的和幂等的。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作 rename 重新命名这个临时文件。</p>
<p>如果一个任务产生了多个输出文件，我们没有提供类似两阶段提交的原子操作支持这种情况。因此，对于会产生多个输出文件、并且对于跨文件有一致性要求的任务，都必须是确定性的任务。但是在实际应用过程中，这个限制还没有给我们带来过麻烦。</p>
<h3 id="跳过损坏的记录"><a href="#跳过损坏的记录" class="headerlink" title="跳过损坏的记录"></a>跳过损坏的记录</h3><p>有时候，用户程序中的 bug 导致 Map 或者 Reduce 函数在处理某些记录的时候 crash 掉，MapReduce 操作无法顺利完成。MapReduce提供了一种执行模式，在这种模式下，为了保证保证整个处理能继续进行，MapReduce会检测哪些记录导致确定性的crash，并且跳过这些记录不处理。</p>
<p>每个 worker 进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus errror）。 在执行 Map 或者 Reduce 操作之前，MapReduce 库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将用“最后一口气”通过 UDP 包向 master 发送处理的最后一条记录的序号。当 master看到在处理某条特定记录不止失败一次时，master 就标志着条记录需要被跳过，并且在下次重新执行相关的 Map 或者 Reduce 任务的时候跳过这条记录。</p>
<h3 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h3><p>通过使用本地版本的MapReduce 库，MapReduce 操作在本地计算机上顺序的执行，可以简化调试、profile 和小规模测试</p>
<h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p>master 使用嵌入式的 HTTP 服务器（如 Jetty）显示一组状态信息页面，用户可以监控各种执行状态。状态信息页面显示了包括计算执行的进度，比如已经完成了多少任务、有多少任务正在处理、输入的字节数、中间数据的字节数、输出的字节数、处理百分比等等。页面还包含了指向每个任务的 stderr 和 stdout 文件的链接。用户根据这些数据预测计算需要执行大约多长时间、是否需要增加额外的计算资源。这些页面也可以用来分析什么时候计算执行的比预期的要慢。</p>
<p>另外， 处于最顶层的状态页面显示了哪些 worker 失效了， 以及他们失效的时候正在运行的 Map 和 Reduce任务。这些信息对于调试用户代码中的 bug 很有帮助。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>MapReduce 库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇 German 文档等等。<br>为了使用这个特性，用户在程序中创建一个命名的计数器对象，在 Map 和 Reduce 函数中相应的增加计数器的值<br>这些计数器的值周期性的从各个单独的worker机器上传递给master （附加在ping的应答包中传递）。master把执行成功的 Map 和 Reduce 任务的计数器值进行累计，当 MapReduce 操作完成之后，返回给用户代码。 计数器当前的值也会显示在 master 的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，master 要检查重复运行的 Map 或者 Reduce 任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/10/TCP-IP%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/TCP-IP%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">TCP/IP补充</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-10 17:40:46 / 修改时间：18:08:03" itemprop="dateCreated datePublished" datetime="2020-02-10T17:40:46+08:00">2020-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Nagle"><a href="#Nagle" class="headerlink" title="Nagle"></a>Nagle</h2><p> TCP连接上最多能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组；相仿，TCP收集这些少量的分组，并在确认到达来时以一个分组的方式发出去</p>
<h2 id="TCP怎么判断是超时还是丢失"><a href="#TCP怎么判断是超时还是丢失" class="headerlink" title="TCP怎么判断是超时还是丢失"></a>TCP怎么判断是超时还是丢失</h2><ul>
<li>在一定时期内未收到报文确认，报文重发</li>
<li>接收端检测到报文丢失，重复发送ack报文，发送端收到三个以上重复报文，快重传</li>
</ul>
<h2 id="cwnd单位"><a href="#cwnd单位" class="headerlink" title="cwnd单位"></a>cwnd单位</h2><ul>
<li>cwnd初始值为1 -&gt; 1个报文段</li>
<li>ssthresh 65535字节</li>
</ul>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><ul>
<li>UDP校验和包含首部和数据，是可选项</li>
<li>TCP校验和：TCP首部+TCP数据+TCP伪首部，是必需的</li>
</ul>
<h2 id="TCP同时打开和同时关闭"><a href="#TCP同时打开和同时关闭" class="headerlink" title="TCP同时打开和同时关闭"></a>TCP同时打开和同时关闭</h2><h3 id="同时打开"><a href="#同时打开" class="headerlink" title="同时打开"></a>同时打开</h3> <img src="/2020/02/10/TCP-IP%E8%A1%A5%E5%85%85/TCP%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80.png" class="">

<p> 需要交换四个报文段，比三次握手多一个。<br>任何一端既是客户端又是服务器端</p>
<h3 id="同时关闭"><a href="#同时关闭" class="headerlink" title="同时关闭"></a>同时关闭</h3> <img src="/2020/02/10/TCP-IP%E8%A1%A5%E5%85%85/TCP%E5%90%8C%E6%97%B6%E5%85%B3%E9%97%AD.png" class="">

<p> 同时关闭与正常关闭使用的段交换数目相同</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/10/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">c++面向对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 17:27:51" itemprop="dateCreated datePublished" datetime="2020-02-10T17:27:51+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-18 16:07:14" itemprop="dateModified" datetime="2020-02-18T16:07:14+08:00">2020-02-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
<ul>
<li>将变化隔离</li>
<li>便于使用</li>
<li>提高重用性</li>
<li>提高安全性</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。<br>父类又称基类，超类；子类又称派生类。<br>子类可以直接访问父类中的非私有的属性和行为。</p>
<ul>
<li>提高了代码的复用性。</li>
<li>让类与类之间产生了关系，提供了多态的前提。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。<br>多态性在C++中是通过虚函数实现的。虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为“覆盖”，或者称为“重写”。子类重写父类中虚函数时，即使不用virtual声明，该重载函数也是虚函数。</p>
<ul>
<li>极大的提高了代码的重用。</li>
</ul>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><table>
<thead>
<tr>
<th>访问</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>派生类</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>外部的类</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>基类的公有成员也是派生类的公有成员<br>保护成员也是派生类的保护成员<br>私有成员不能直接被派生类访问，当可通过调用基类的公有和保护成员访问</p>
<h3 id="protect"><a href="#protect" class="headerlink" title="protect"></a>protect</h3><p>基类的公有和保护成员将继承为派生类的保护成员</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>基类的公有和保护成员将继承为派生类的私有成员</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/10/linux%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/linux%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">linux命令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-10 11:31:54 / 修改时间：11:39:35" itemprop="dateCreated datePublished" datetime="2020-02-10T11:31:54+08:00">2020-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>shutdown -h now 
         -r

man (命令说明书)

ls -a 隐藏文件
   -l

mkdir -f (询问)
      -r (递归)

mv 剪切/重命名
cp 复制

find /usr/tmp -name &apos;a*&apos; 查找目录下以a开头的文件

touch 新建文件
grep

pwd 查看当前路径
ps -ef 查看所有正在运行的进程
kill pid

ifconfig
ping

netstat -an 查看当前系统端口
netstat -an|grep 8080
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">GJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
